### 如何保证缓存和数据库数据库一致？
#### 缓存+数据库读写：
读：先读缓存，有直接返回不查数据库。缓存查不到就查数据库，返回同时更新缓存。
写：先删除缓存，再写数据库。为啥先删除缓存，保证一定程度的数据一致，防止写入数据库成功，删除缓存失败的情况。
#### 还是存在不一致情形：
多线程并发读、写时，比如A线程写，删除了缓存，准备写入数据库期间，线程B读操作，先读缓存没有，再查询数据，然后更新缓存，B线程完成这一系列操作之后，A线程才写入数据，但是缓存的数据还是旧的值，这就导致了缓存和数据库的数据不一致。
这种情况在读并发高的情况写容易出现。
#### 怎样解决上面这个问题？
当查询缓存为空时，将改查询操作放入读写队列中，需等前面的写操作完成之后再去读数据库更新缓存。这种解决方法还可以合并相同的查询项，后面来查询操作如果和前面的查询是查询同样的数据，则后面的操作可以轮询缓存，就避免再去查询数据库了。

#### 缓存穿透
每次都不走缓存，直接走数据库，把数据库压挂了
设置一个缓存UNKNOWN 把查询不到的id都存入缓存。 set id UNKNOWN
过滤不存在的id

#### 缓存更新的并发竞争问题？
背景：当多线程更新数据更新缓存时，线程更新数据库的顺序和更新缓存的顺序不一样，导致缓存背更新成了旧的值了。
解决办法：每次查询数据库时，查出数据库的数据的版本号（时间戳），每次更新数据时，对比缓存的数据版本号，如果比缓存的新，就更新缓存，如果比缓存的旧，就放弃更新。

#### Redis 分布式锁
zookeeper分布式锁实现机制

连接redis：redis-cli -h 192.168.9.4 -p 6379
登录：auth redis@123
查看所有的键：keys *
清空缓存：flushall